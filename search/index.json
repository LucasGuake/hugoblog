[{"content":"\rTip\r注意:资源来自网络，本站内容仅供学习交流使用。\n原理 我们先放置3x3的空格数组。下棋时相当于给数组赋值，并判断连续三个值是否相等来判断是否连三子，以达到三子棋的效果。\nC语言三子棋实现过程 构思 打印菜单。 初始化棋盘。 玩家下棋，电脑下棋。 判断输赢。 主程序 菜单 在编写此工程时，我们分别建立文件头文件game.h ， 源文件game.c ，源文件main.c。并在源文件main.c和 源文件game.c中调用头文件game.h。如下图所示(图中仅演示main.c的包含) 接下来在在源文件main.c中编写主程序和菜单函数menu();运用循环嵌套，使程序能够正常运行。由于游戏程序尚未编写，我们用打印”游戏开始“代替。\n接下来我们开始编写游戏程序。\n游戏程序 初始化棋盘和棋盘显示 创建game函数，void类型。将上文中 printf(”游戏开始“); ，替换为game();函数。并在game函数中添加初始化棋盘和显示棋盘操作。 在game.h中定义棋盘的长(ROW)和宽(COL)，后续可以直接应用，便于直接更改。(game.h中引入头文件\u0026lt;stdio.h\u0026gt;操作此处已省去，请注意添加) 接着，我们进行初始化棋盘和棋盘显示操作。 先在 game.h 中添加以下代码，以声明函数\n然后，我们正式进入初始化棋盘和显示棋盘操作的编写。 在game.c中添加以下代码。\nNote\r正如图解原理中展示的一样，这里生成了3x3的空格数组\n然后是打印棋盘代码，如下图所示\n此时，我们就完成了初始化棋盘和棋盘显示，调试结果如下. 接下来，我们编写 电脑和玩家下棋程序\n游戏程序 玩家下棋和电脑下棋 玩家下棋\n先在头文件game.h中添加玩家下棋的函数声明。（图片见上文\u0026lt;头文件定义\u0026gt;其余内容一致，仅需将变量名改为PlayerMove即可。\n然后在game.c中编写程序，内容如下。\nNote\r此内容表示用读取的坐标来检测数组中是否有空格，有即用* 替换，实现下棋的效果。\n电脑下棋\n先在头文件game.h中添加玩家下棋的函数声明。（图片见上文\u0026lt;头文件定义\u0026gt;其余内容一致，仅需将变量名改为 ComputerMove即可。\n随即我们继续在game.c中编写\n同时，头文件game.h中需要引入相应头文件：stdlib.h和time.h\n需要在main.c的主程序中添加srand((unsigned int) time(NULL));以实现全随机 Note\r1.电脑扫描棋盘上的空格，将空格替换为#，实现下棋效果。\n2.由于此处为C语言初阶演示，电脑下棋位置为随机数（rand）。有意向者可自行编写逻辑。\n游戏程序 判断输赢 Note\r我们分别用玩家赢 *电脑赢 #平局 Q继续 C来判断输赢\n1.在game.h中声明IsWin函数\n2.在game.c中编写IsWin函数\nNote\r这是一种死的做法，有意向可以自行编写，为4子棋5子棋等做适配。\n游戏程序 game函数汇集 main.c中的game函数具体内容如下。\n游戏程序 调试结果 C语言三子棋 全代码 game.h的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #pragma once #define ROW 3 #define COL 3 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;windows.h\u0026gt; //初始化棋盘 void InitBoard(char board[ROW][COL], int row, int col); //打印棋盘 void DisplayBoard(char board[ROW][COL], int row, int col); //玩家下棋 void PlayerMove(char board[ROW][COL], int row, int col); //电脑下棋 //找空白位置随即下 void ComputerMove(char board[ROW][COL], int row, int col); ///判断输赢 char IsWin(char board[ROW][COL], int row, int col); //玩家赢 * //电脑赢 # //平局 Q //继续 C game.c的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 #define _CRT_SECURE_NO_WARNINGS #include \u0026#34;game.h\u0026#34; //初始化棋盘 //row横 col竖 void InitBoard(char board[ROW][COL], int row, int col) { int i = 0; int j = 0; for (i = 0;i \u0026lt; row;i++) { for (j = 0;j \u0026lt; col;j++) { board[i][j] = \u0026#39; \u0026#39;; } } } //打印棋盘 //以下内容较难 //建议复习 void DisplayBoard(char board[ROW][COL], int row, int col) { int i = 0; for (i = 0;i \u0026lt; row;i++) //行 { //打印数据(列） int j = 0; for (j = 0;j \u0026lt; col ;j++) //列 { printf(\u0026#34; %c \u0026#34;, board[i][j]); //打印每个格子的%c if (j \u0026lt; col - 1) ///最后一列竖线不打印 printf(\u0026#34;|\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); //打印分割（行） if (i \u0026lt; row - 1) //最后一行横线不打印 { int j = 0; for (j = 0;j \u0026lt; col;j++) { printf(\u0026#34;---\u0026#34;); if (j \u0026lt; col - 1) //最后一列竖线不打印 printf(\u0026#34;|\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } } } //玩家下棋 void PlayerMove(char board[ROW][COL], int row, int col) { int x = 0; int y = 0; while (1) { printf(\u0026#34;请输入坐标：\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); if (x \u0026gt;= 1 \u0026amp;\u0026amp; x \u0026lt;= row \u0026amp;\u0026amp; y \u0026gt;= 1 \u0026amp;\u0026amp; y \u0026lt;= col) { if (board[x - 1][y - 1] == \u0026#39; \u0026#39;) { board[x - 1][y - 1] = \u0026#39;*\u0026#39;; break; } else { printf(\u0026#34;这里已有棋子，请重下\\n\u0026#34;); } } else printf(\u0026#34;坐标输入错误,请重新输入\\n\u0026#34;); } } //电脑下棋 void ComputerMove(char board[ROW][COL], int row, int col) { printf(\u0026#34;电脑下棋：已完成\\n\u0026#34;); int x = 0; int y = 0; while(1) { x = rand() % row; y = rand() % col; if (board[x][y] == \u0026#39; \u0026#39;) { board[x][y] = \u0026#39;#\u0026#39;; break; } } } //平局函数 满了返回1，不满返回0 int IsFull(char board[ROW][COL], int row, int col) { int i = 0; int j = 0; for (i = 0;i \u0026lt; row;i++) { for (j = 0;j \u0026lt; col;j++) { if (board[i][j] == \u0026#39; \u0026#39;) return 0; } } return 1; } //判断输赢 char IsWin(char board[ROW][COL], int row, int col) { //行 int i = 0; for (i = 0;i \u0026lt; row;i++) { if (board[i][0] == board[i][1] \u0026amp;\u0026amp; board[i][1] == board[i][2] \u0026amp;\u0026amp; board[i][i] != \u0026#39; \u0026#39;) return board[i][1]; } //列 int j = 0; for (i = 0;i \u0026lt; col;i++) { if (board[0][j] == board[1][j] \u0026amp;\u0026amp; board[2][j] == board[1][j] \u0026amp;\u0026amp; board[1][j] != \u0026#39; \u0026#39;) return board[1][j]; } //对角线 if (board[0][0] == board[1][1] \u0026amp;\u0026amp; board[1][1] == board[2][2] \u0026amp;\u0026amp; board[1][1] != \u0026#39; \u0026#39;) { return board[1][1]; } if (board[0][2] == board[1][1] \u0026amp;\u0026amp; board[1][1] == board[2][0] \u0026amp;\u0026amp; board[1][1] != \u0026#39; \u0026#39;) { return board[1][1]; } //平局 if (IsFull(board, row, col)) { return \u0026#39;Q\u0026#39;; } //游戏继续 return \u0026#39;C\u0026#39;; } main.c的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #define _CRT_SECURE_NO_WARNINGS #include \u0026#34;game.h\u0026#34; //菜单 void menu() { printf(\u0026#34;-------------------------------\\n\u0026#34;); printf(\u0026#34;| 三子棋小游戏 |\\n\u0026#34;); printf(\u0026#34;| |\\n\u0026#34;); printf(\u0026#34;| 1.开始 0.退出 |\\n\u0026#34;); printf(\u0026#34;-------------------------------\\n\u0026#34;); printf(\u0026#34;游戏规则：输入（行 列）以下棋。三子为赢。玩家为*，电脑为#\\n\u0026#34;); } //游戏程序 void game() { char ret = 0; char board[ROW][COL]; //初始化棋盘 InitBoard(board, ROW, COL); DisplayBoard(board, ROW, COL); while (1) { //玩家下 PlayerMove(board,ROW,COL); DisplayBoard(board, ROW, COL); ret = IsWin(board, ROW, COL); //判断输赢 if (ret != \u0026#39;C\u0026#39;) { break; } Sleep(1000); //电脑下 ComputerMove(board, ROW, COL); DisplayBoard(board, ROW, COL); ret = IsWin(board, ROW, COL); if (ret != \u0026#39;C\u0026#39;) { break; } Sleep(1000); } if (ret == \u0026#39;*\u0026#39;) printf(\u0026#34;玩家赢，游戏结束\\n\u0026#34;); if (ret == \u0026#39;#\u0026#39;) printf(\u0026#34;电脑赢，游戏结束\\n\u0026#34;); if(ret == \u0026#39;Q\u0026#39;) printf(\u0026#34;平局，游戏结束\\n\u0026#34;); Sleep(1000); DisplayBoard(board, ROW, COL); } int main() { srand((unsigned int) time(NULL)); int input = 0; do { menu(); printf(\u0026#34;请选择:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); switch (input) { case 1: game(); break; case 0: printf(\u0026#34;退出游戏\\n\u0026#34;); break; default: printf(\u0026#34;输入错误，请重新输入\\n\u0026#34;); } } while (input); //0为假跳出循环 return 0; } 总结 对于学完C语言初阶_数组部分的人来说，一个三子棋程序可谓是汇聚其精华。初学者可能一下无法想出各部分的写法，但只要慢慢学习阅读了解代码，我们最终都能理解各部分代码的含义，并会发现三子棋的实现并不难。慢慢深入熟悉之后，这样的代码对我们来说或将小菜一碟。\n精通代码的可以尝试研究一下四子棋，五子棋的实现方法。就像是三阶魔方对于四阶魔方乃至五阶魔方一样，其方法十分相似而又些许不同。\n参考资料 [1] C语言鹏哥. 【C语言初阶】三子棋， 代码学习， 2023-03-27 ","date":"2025-08-12T00:00:00Z","image":"http://localhost:1782/p/c_main001/background_hu_a43693add0ec9d57.png","permalink":"http://localhost:1782/p/c_main001/","title":"C语言学习初阶_数组"},{"content":"\rTip\r注意:资源来自网络，本站内容仅供学习交流使用。\n前言 递归大多不要求搞清楚实际程序运行，推导公式，理清步骤。汉诺塔问题和青蛙跳台问题正是两道极为经典的函数递归题目。对此进行分析学习，有助于我们对加深我们对递归的理解运用。\n汉诺塔问题的分析与解决。 汉诺塔递归思想分析 汉诺塔要求 汉诺塔设定有三个杆：起始杆，中转杆，目标杆。\n设定起始杆上有n个盘子，要求盘子在杆上必须从大到小放置。一次移动一个盘子。要求把起始杆上盘子全部移动到目标杆上。\n汉诺塔递归思想分析 C语言描述 我们分别将起始杆，中转杆，目标杆命名为pos1,pos2,pos3，用n代表初始杆上的盘子数目，初始化为1。\n可见，函数递推是层层套函数，将一个大的问题拆解成若干小问题。运用函数递推时，我们也不必太过推敲细枝末节，掌握大体逻辑即可。\n汉诺塔 c语言全代码(含借鉴） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; //pos1起始位置 pos2中转位置,pos3目的位置。 void move(char* pos1, char* pos2) //char类型只能表示单个字符 可以用char*pos1来读取地址。 { //此处pos1,pos2仅表示起点和终点 printf(\u0026#34;%s -\u0026gt; %s\\n\u0026#34;, pos1, pos2); //模拟移动盘子的过程 } void Hanoi(int n, char* pos1, char* pos2, char* pos3) // { if (n == 1) //仅一个时，仅把pos1移到pos3即可 { move(pos1, pos3); } else { Hanoi(n - 1,pos1,pos3,pos2); //此处实现 将n-1个pos1上的盘子移动到pos2上 move(pos1, pos3); //将pos1上最后一个移动到pos3 Hanoi(n - 1, pos2, pos1, pos3);//将n-1个从pos2借助pos1移动的pos3。类似n-1个盘子的移法。 } } int main() { int n = 1; //对n进行初始化; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); //下面用中文展示 若使用用单字符A B C表示各杆，则函数仅需char pos即可 Hanoi(n,\u0026#34;起始杆\u0026#34;,\u0026#34;中转杆\u0026#34;,\u0026#34;目标杆\u0026#34;); //我这里用的是字符串，函数用char*pos1读取地址即可。 return 0; } 青蛙跳台阶问题的分析与解决。 青蛙跳台阶问题分析 青蛙跳台阶问题条件 青蛙跳台阶问题分析 为证明，我们可以运用高中数学知识进行分析。以下内容涵盖所有情况。\n设有n个台阶。我们不管它前面怎么跳，我们先让它到n-2台阶上，然后跳2步到n级上。\n我们不管它前面怎么跳，我们让它跳到n-1台阶上，一步跳到b级上。\n青蛙跳台 C语言代码 (原创) C语言部分就十分简单了，这里直接列出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; int count(int x) { if (x \u0026lt;= 2) return x; else return count(x - 1) + count(x - 2); //递归 } int main() { initial: int n = 1; //初始化台阶数为1 printf(\u0026#34;请输入台阶数：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); if (n == 0) { printf(\u0026#34;输入错误,请重新输入\\n\u0026#34;); goto initial; } int c = count(n); printf(\u0026#34;\\n共有%d种跳法\u0026#34;, c); return 0; } 总结 面对递归问题，我们要从整体上来看待问题，对其做出分析即可。如果我们用大脑推测其内部的每一个细节只会平添头疼。\n参考资料 [1] C语言博哥. C语言实现汉诺塔， 代码参考， 2021-8-17 [2] 从0开始数. 汉诺塔小游戏和递归思想， 视频引用. 2021-01-21 [3] 沙猪教写程序. 【C语言】用递归解决汉诺塔问题太容易不过了，仅引用图片， 2023-12-07 [4] 渡一机构. 沙猪教写程序， js教程, 2023-07-08 [5] 圥忈ゼ. 【青蛙跳台阶问题 —— (三种算法）】，仅引用其介绍部分，不参考代码, CSDN, 2023-11-27 ","date":"2025-08-11T00:00:00Z","image":"http://localhost:1782/p/c_extra001/background_hu_8466c3cadd0c467.png","permalink":"http://localhost:1782/p/c_extra001/","title":"C语言学习DLC_函数递归"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 本站额外加入一下内容\nTip\r这是markdown的引用块语法\nNote\r这是markdown的引用块语法\nWarning\r这是markdown的引用块语法\nError\r这是markdown的引用块语法\nCTRL + C\nH2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob | 27 Alice | 23\nInline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image Markdown 额外语法 The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-08-11T00:00:00Z","image":"http://localhost:1782/p/markdown_study/main_hu_f81e4f6a0e8f487b.png","permalink":"http://localhost:1782/p/markdown_study/","title":"markdown语法英文版"}]